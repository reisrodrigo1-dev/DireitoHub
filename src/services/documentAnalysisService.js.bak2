// Servi√ßo para an√°lise inteligente de documentos e extra√ß√£o de informa√ß√µes
import { AI_CONFIG } from '../config/aiConfig.js';

// Estrutura de informa√ß√µes esperadas por tipo de prompt
const REQUIRED_INFORMATION = {
  'apelacao-criminal': {
    acusado: {
      nome: 'Nome completo do acusado',
      dataNascimento: 'Data de nascimento',
      cpf: 'CPF/RG',
      endereco: 'Endere√ßo'
    },
    processo: {
      numeroProcesso: 'N√∫mero do processo',
      comarca: 'Comarca/Tribunal',
      juiz: 'Juiz respons√°vel'
    },
    crimes: {
      acusacoes: 'Crimes imputados',
      artigos: 'Artigos do C√≥digo Penal',
      circunstancias: 'Circunst√¢ncias agravantes/atenuantes'
    },
    sentenca: {
      resultado: 'Resultado da senten√ßa (condena√ß√£o/absolvi√ß√£o)',
      pena: 'Pena aplicada',
      regime: 'Regime inicial',
      data: 'Data da senten√ßa'
    },
    defesa: {
      fundamentosPrincipais: 'Pontos principais de contesta√ß√£o',
      provasAFavor: 'Provas que favorecem o acusado',
      circunstanciasPositivas: 'Circunst√¢ncias positivas n√£o reconhecidas'
    }
  }
};

// Palavras-chave para detectar informa√ß√µes no texto
const KEYWORDS_MAPPING = {
  'apelacao-criminal': {
    acusado: [
      'acusado', 'r√©u', 'denunciado', 'investigado', 'indiciado',
      'nome:', 'natural de', 'nascido em', 'cpf', 'rg'
    ],
    processo: [
      'processo', 'n√∫mero', 'autos', 'comarca', 'tribunal', 'vara judicial',
      'ju√≠zo', 'juiz', 'senten√ßa'
    ],
    crimes: [
      'crime', 'delito', 'tr√°fico', 'homic√≠dio', 'roubo', 'furto',
      'artigo', 'c√≥digo penal', 'cp', 'lei', 'crime doloso'
    ],
    sentenca: [
      'condenado', 'absolvido', 'pena', 'anos', 'meses', 'regime',
      'pris√£o', 'fechado', 'semiaberto', 'aberto', 'senten√ßa'
    ],
    provas: [
      'testemunha', 'depoimento', 'prova', 'evid√™ncia', 'documento',
      'per√≠cia', 'laudo', 'apreendido'
    ]
  }
};

/**
 * Pr√©-processa o conte√∫do do documento para melhorar a extra√ß√£o
 */
const preprocessDocument = (content) => {
  if (!content) return '';

  return content
    // Normalizar espa√ßos em branco
    .replace(/\s+/g, ' ')
    // Remover caracteres especiais que podem vir do OCR, mantendo pontua√ß√£o legal
    .replace(/[^\w\s.,;:()/\\\-\n]/g, '')
    // Normalizar refer√™ncias a artigos
    .replace(/art\.?\s*(\d+)/gi, 'artigo $1')
    // Normalizar refer√™ncias ao c√≥digo penal
    .replace(/c√≥d\.?\s*penal/gi, 'c√≥digo penal')
    .replace(/cp\.?/gi, 'c√≥digo penal')
    // Normalizar termos comuns
    .replace(/r√©u/gi, 'acusado')
    .replace(/denunciado/gi, 'acusado')
    // Limitar tamanho para n√£o exceder limites da API
    .substring(0, 12000);
};

/**
 * Analisa um documento e extrai informa√ß√µes relevantes
 * @param {string} documentContent - Conte√∫do do documento (pode ser m√∫ltiplos docs concatenados)
 * @param {string} promptType - Tipo de prompt (ex: 'apelacao-criminal')
 * @returns {Promise<Object>} An√°lise com informa√ß√µes extra√≠das e faltantes
 */
const analyzeDocument = async (documentContent, promptType) => {
  try {
    console.log('üîç Iniciando an√°lise do documento para:', promptType);
    
    if (!documentContent || documentContent.trim().length === 0) {
      return {
        success: false,
        error: 'Documento vazio',
        extractedInfo: {},
        missingInfo: [],
        confidence: 0
      };
    }

    // Detectar se h√° m√∫ltiplos documentos (marcados com ---)
    const hasMultipleDocs = documentContent.includes('---');
    console.log(`üìö An√°lise ${hasMultipleDocs ? 'M√öLTIPLA' : 'SIMPLES'} de documento(s)`);

    // Para apela√ß√£o criminal, fazer an√°lise mais detalhada
    if (promptType === 'apelacao-criminal') {
      return await analyzeApelacaoCriminal(documentContent, hasMultipleDocs);
    }

    // Para outros tipos, retornar an√°lise gen√©rica
    return await analyzeGenericDocument(documentContent, promptType);

  } catch (error) {
    console.error('‚ùå Erro ao analisar documento:', error);
    return {
      success: false,
      error: error.message,
      extractedInfo: {},
      missingInfo: []
    };
  }
};

/**
 * Analisa documento especificamente para Apela√ß√£o Criminal
 */
const analyzeApelacaoCriminal = async (documentContent, hasMultipleDocs = false) => {
  // Pr√©-processar o documento
  const processedContent = preprocessDocument(documentContent);

  const docContext = hasMultipleDocs
    ? 'Voc√™ est√° recebendo M√öLTIPLOS DOCUMENTOS. Extraia informa√ß√µes de TODOS eles em conjunto.'
    : 'Voc√™ est√° recebendo UM √öNICO DOCUMENTO.';

  const analysisPrompt = `${docContext}

Analise este documento jur√≠dico de apela√ß√£o criminal e extraia APENAS as informa√ß√µes objetivas encontradas.

INSTRU√á√ïES IMPORTANTES:
- Procure por nomes em se√ß√µes como "acusado", "r√©u", "denunciado", "investigado"
- Crimes est√£o tipicamente em "artigos", "imputados", "praticou", "crime de"
- Senten√ßas mencionam "condenado", "absolvido", "pena de", "regime", "pris√£o"
- Ignore informa√ß√µes irrelevantes, especulativas ou de terceiros
- Para crimes, liste apenas os crimes efetivamente imputados
- Para artigos, extraia apenas n√∫meros de artigos mencionados

EXEMPLOS DE EXTRA√á√ÉO:

Documento: "O acusado JOS√â DA SILVA, nascido em 15/03/1985, foi condenado por tr√°fico de drogas (artigo 33 da Lei 11.343/06) √† pena de 5 anos de reclus√£o em regime fechado."
Extra√ß√£o: {
  "acusado": {"nome": "JOS√â DA SILVA"},
  "crimes": {"acusacoes": ["tr√°fico de drogas"], "artigos": ["33"]},
  "sentenca": {"resultado": "condenado", "pena": "5 anos de reclus√£o", "regime": "fechado"}
}

Documento: "A r√© MARIA SANTOS foi absolvida da acusa√ß√£o de furto simples (artigo 155 do C√≥digo Penal)."
Extra√ß√£o: {
  "acusado": {"nome": "MARIA SANTOS"},
  "crimes": {"acusacoes": ["furto simples"], "artigos": ["155"]},
  "sentenca": {"resultado": "absolvida"}
}

AGORA ANALISE ESTE DOCUMENTO:

${processedContent}

Responda EXATAMENTE neste formato JSON (use null para informa√ß√µes n√£o encontradas):
{
  "acusado": {
    "nome": "nome completo ou null",
    "dataNascimento": "dd/mm/yyyy ou null",
    "cpf": "somente n√∫meros ou null",
    "endereco": "endere√ßo completo ou null"
  },
  "processo": {
    "numero": "n√∫mero completo do processo ou null",
    "comarca": "comarca/tribunal ou null",
    "vara": "vara judicial ou null"
  },
  "crimes": {
    "acusacoes": ["lista de crimes imputados" ou null],
    "artigos": ["lista de artigos citados" ou null]
  },
  "sentenca": {
    "resultado": "condenado/absolvido ou null",
    "pena": "descri√ß√£o completa da pena ou null",
    "regime": "fechado/semiaberto/aberto ou null"
  },
  "evidenciasEncontradas": ["tipos de prova mencionados" ou null]
}`;

  try {
    console.log('ü§ñ Enviando documento para an√°lise OpenAI...');

    const response = await fetch(AI_CONFIG.API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${AI_CONFIG.API_KEY}`
      },
      body: JSON.stringify({
        model: AI_CONFIG.MODEL,
        messages: [
          {
            role: 'system',
            content: 'Voc√™ √© um assistente jur√≠dico especializado em an√°lise de documentos processuais. Extraia APENAS informa√ß√µes objetivas encontradas no texto. Retorne sempre JSON v√°lido, mesmo que incompleto.'
          },
          {
            role: 'user',
            content: analysisPrompt
          }
        ],
        temperature: 0.1, // Mais preciso para textos legais
        max_tokens: 2000, // Aumentado para respostas mais completas
        presence_penalty: 0,
        frequency_penalty: 0.1
      })
    });

    if (!response.ok) {
      throw new Error(`Erro API OpenAI: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    const analysisText = data.choices[0].message.content.trim();

    console.log('‚úÖ Resposta OpenAI recebida, processando...');

    // Parse JSON da resposta
    let extractedData = {};
    try {
      const jsonMatch = analysisText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        extractedData = JSON.parse(jsonMatch[0]);
      } else {
        // Tentar parse direto se n√£o houver markdown
        extractedData = JSON.parse(analysisText);
      }
    } catch (parseError) {
      console.warn('‚ö†Ô∏è Falha ao fazer parse do JSON da OpenAI:', parseError);
      console.log('Resposta recebida:', analysisText.substring(0, 500));
      extractedData = parseJsonFlexible(analysisText);
    }

    // Validar e limpar dados extra√≠dos
    extractedData = validateAndCleanExtractedData(extractedData);

    // Identificar informa√ß√µes faltantes
    const missingInfo = identifyMissingInfo(extractedData, 'apelacao-criminal');
    const hasAllInfo = missingInfo.length === 0;

    console.log('‚úÖ An√°lise conclu√≠da - Informa√ß√µes faltantes:', missingInfo.length);

    return {
      success: true,
      extractedInfo: extractedData,
      missingInfo: missingInfo,
      hasAllInfo: hasAllInfo,
      confidence: calculateConfidence(extractedData)
    };

  } catch (error) {
    console.error('‚ùå Erro na an√°lise via OpenAI:', error);
    // Fallback para an√°lise b√°sica por palavras-chave
    return performKeywordAnalysis(documentContent, 'apelacao-criminal');
  }
};

/**
 * An√°lise gen√©rica para outros tipos de prompts
 */
const analyzeGenericDocument = async (documentContent, promptType) => {
  console.log('üìã An√°lise gen√©rica para:', promptType);
  
  return {
    success: true,
    extractedInfo: {
      hasContent: documentContent.length > 0,
      characterCount: documentContent.length,
      paragraphCount: documentContent.split('\n\n').length
    },
    missingInfo: [],
    hasAllInfo: true,
    confidence: 0.8
  };
};

/**
 * An√°lise por palavras-chave como fallback melhorado
 */
const performKeywordAnalysis = (content, promptType) => {
  console.log('üîë An√°lise por palavras-chave para:', promptType);

  const contentLower = content.toLowerCase();
  const extracted = {};

  if (promptType === 'apelacao-criminal') {
    // Extra√ß√£o espec√≠fica para campos cr√≠ticos

    // Nome do acusado - procurar padr√µes comuns
    const nomePatterns = [
      /acusado[.:]\s*([A-Z\s√á√É√ï√Ç√ä√é√î√õ√Å√â√ç√ì√ö√Ä√à√å√í√ô]{3,})/i,
      /r√©u[.:]\s*([A-Z\s√á√É√ï√Ç√ä√é√î√õ√Å√â√ç√ì√ö√Ä√à√å√í√ô]{3,})/i,
      /denunciado[.:]\s*([A-Z\s√á√É√ï√Ç√ä√é√î√õ√Å√â√ç√ì√ö√Ä√à√å√í√ô]{3,})/i,
      /investigado[.:]\s*([A-Z\s√á√É√ï√Ç√ä√é√î√õ√Å√â√ç√ì√ö√Ä√à√å√í√ô]{3,})/i
    ];

    for (const pattern of nomePatterns) {
      const match = content.match(pattern);
      if (match && match[1].trim().length > 2) {
        extracted.acusado = extracted.acusado || {};
        extracted.acusado.nome = match[1].trim().toUpperCase();
        break;
      }
    }

    // N√∫mero do processo
    const processoPattern = /(\d{7}-\d{2}\.\d{4}\.\d{1,2}\.\d{2}\.\d{4})/;
    const processoMatch = content.match(processoPattern);
    if (processoMatch) {
      extracted.processo = extracted.processo || {};
      extracted.processo.numero = processoMatch[1];
    }

    // Crimes - procurar men√ß√µes espec√≠ficas
    const crimesList = [];
    const crimePatterns = [
      /tr√°fico(?:\s+de\s+droga)?/i,
      /homic√≠di(?:o|o)/i,
      /roubo/i,
      /furto/i,
      /estupro/i,
      /latroc√≠ni(?:o|o)/i,
      /extors√£o/i,
      /crime(?:\s+de)?/i
    ];

    crimePatterns.forEach(pattern => {
      if (pattern.test(contentLower)) {
        const match = contentLower.match(pattern);
        if (match && !crimesList.includes(match[0])) {
          crimesList.push(match[0]);
        }
      }
    });

    if (crimesList.length > 0) {
      extracted.crimes = extracted.crimes || {};
      extracted.crimes.acusacoes = crimesList;
    }

    // Artigos do c√≥digo penal
    const artigos = [];
    const artigoPattern = /artigo\s*(\d+)/gi;
    let artigoMatch;
    while ((artigoMatch = artigoPattern.exec(contentLower)) !== null) {
      const artigo = artigoMatch[1];
      if (!artigos.includes(artigo)) {
        artigos.push(artigo);
      }
    }

    if (artigos.length > 0) {
      extracted.crimes = extracted.crimes || {};
      extracted.crimes.artigos = artigos;
    }

    // Resultado da senten√ßa
    if (contentLower.includes('condenad')) {
      extracted.sentenca = extracted.sentenca || {};
      extracted.sentenca.resultado = 'condenado';
    } else if (contentLower.includes('absolv')) {
      extracted.sentenca = extracted.sentenca || {};
      extracted.sentenca.resultado = 'absolvido';
    }

    // Regime prisional
    const regimePatterns = [
      /regime\s+(fechado|aberto|semi.?aberto)/i,
      /(fechado|aberto|semi.?aberto)/i
    ];

    for (const pattern of regimePatterns) {
      const match = contentLower.match(pattern);
      if (match) {
        extracted.sentenca = extracted.sentenca || {};
        const regime = match[1].toLowerCase();
        if (regime.includes('semi')) {
          extracted.sentenca.regime = 'semiaberto';
        } else {
          extracted.sentenca.regime = regime;
        }
        break;
      }
    }
  }

  const missingInfo = identifyMissingInfo(extracted, promptType);

  return {
    success: true,
    extractedInfo: extracted,
    missingInfo: missingInfo,
    hasAllInfo: missingInfo.length === 0,
    confidence: calculateConfidence(extracted)
  };
};

/**
 * Identifica quais informa√ß√µes est√£o faltando
 */
const identifyMissingInfo = (extractedData, promptType) => {
  const required = REQUIRED_INFORMATION[promptType];
  if (!required) return [];

  const missing = [];

  // Verificar cada categoria
  Object.entries(required).forEach(([category, fields]) => {
    if (typeof fields === 'object') {
      Object.entries(fields).forEach(([field, description]) => {
        const value = extractedData?.[category]?.[field];
        if (!value || value === null || value === '' || (Array.isArray(value) && value.length === 0)) {
          missing.push({
            category,
            field,
            description,
            priority: calculateFieldPriority(category, field)
          });
        }
      });
    }
  });

  // Ordenar por prioridade
  return missing.sort((a, b) => b.priority - a.priority);
};

/**
 * Valida e limpa dados extra√≠dos da an√°lise
 */
const validateAndCleanExtractedData = (data) => {
  if (!data || typeof data !== 'object') return {};

  const cleaned = { ...data };

  // Validar e limpar nome do acusado
  if (cleaned.acusado?.nome) {
    const nome = cleaned.acusado.nome.trim();
    // Verificar se parece um nome v√°lido (pelo menos 2 palavras, letras mai√∫sculas)
    if (nome.length < 3 || !/^[A-Z\s√á√É√ï√Ç√ä√é√î√õ√Å√â√ç√ì√ö√Ä√à√å√í√ô]+$/.test(nome.toUpperCase())) {
      cleaned.acusado.nome = null;
    } else {
      cleaned.acusado.nome = nome.toUpperCase();
    }
  }

  // Validar CPF
  if (cleaned.acusado?.cpf) {
    const cpf = cleaned.acusado.cpf.toString().replace(/\D/g, '');
    if (cpf.length !== 11 || !/^\d{11}$/.test(cpf)) {
      cleaned.acusado.cpf = null;
    } else {
      cleaned.acusado.cpf = cpf;
    }
  }

  // Validar data de nascimento
  if (cleaned.acusado?.dataNascimento) {
    const data = cleaned.acusado.dataNascimento;
    // Aceitar formatos dd/mm/yyyy ou dd-mm-yyyy
    if (!/^\d{2}[\/\-]\d{2}[\/\-]\d{4}$/.test(data)) {
      cleaned.acusado.dataNascimento = null;
    }
  }

  // Validar n√∫mero do processo
  if (cleaned.processo?.numero) {
    const numero = cleaned.processo.numero.toString().trim();
    // Padr√£o brasileiro: 7 d√≠gitos - 2 d√≠gitos . 4 d√≠gitos . 1-2 d√≠gitos . 2 d√≠gitos . 4 d√≠gitos
    if (!/\d{7}-\d{2}\.\d{4}\.\d{1,2}\.\d{2}\.\d{4}/.test(numero)) {
      cleaned.processo.numero = null;
    }
  }

  // Validar crimes - garantir que sejam arrays
  if (cleaned.crimes?.acusacoes && !Array.isArray(cleaned.crimes.acusacoes)) {
    if (typeof cleaned.crimes.acusacoes === 'string') {
      cleaned.crimes.acusacoes = [cleaned.crimes.acusacoes];
    } else {
      cleaned.crimes.acusacoes = null;
    }
  }

  if (cleaned.crimes?.artigos && !Array.isArray(cleaned.crimes.artigos)) {
    if (typeof cleaned.crimes.artigos === 'string') {
      // Extrair apenas n√∫meros de artigos
      const artigos = cleaned.crimes.artigos.match(/\d+/g);
      cleaned.crimes.artigos = artigos || null;
    } else {
      cleaned.crimes.artigos = null;
    }
  }

  // Validar resultado da senten√ßa
  if (cleaned.sentenca?.resultado) {
    const resultado = cleaned.sentenca.resultado.toLowerCase().trim();
    if (!['condenado', 'absolvido', 'condena√ß√£o', 'absolvi√ß√£o'].includes(resultado)) {
      cleaned.sentenca.resultado = null;
    } else {
      // Normalizar para termos padr√£o
      cleaned.sentenca.resultado = resultado.includes('conden') ? 'condenado' : 'absolvido';
    }
  }

  // Validar regime
  if (cleaned.sentenca?.regime) {
    const regime = cleaned.sentenca.regime.toLowerCase().trim();
    const regimesValidos = ['fechado', 'semiaberto', 'semi-aberto', 'aberto'];
    if (!regimesValidos.some(r => regime.includes(r))) {
      cleaned.sentenca.regime = null;
    } else {
      // Normalizar
      if (regime.includes('semi')) cleaned.sentenca.regime = 'semiaberto';
      else if (regime.includes('fechado')) cleaned.sentenca.regime = 'fechado';
      else if (regime.includes('aberto')) cleaned.sentenca.regime = 'aberto';
    }
  }

  // Validar evid√™ncias - garantir que seja array
  if (cleaned.evidenciasEncontradas && !Array.isArray(cleaned.evidenciasEncontradas)) {
    if (typeof cleaned.evidenciasEncontradas === 'string') {
      cleaned.evidenciasEncontradas = [cleaned.evidenciasEncontradas];
    } else {
      cleaned.evidenciasEncontradas = null;
    }
  }

  return cleaned;
};

/**
 * Calcula prioridade de um campo (para decidir em qual ordem fazer perguntas)
 */
const calculateFieldPriority = (category, field) => {
  const priorities = {
    'acusado.nome': 100,
    'processo.numero': 95,
    'crimes.acusacoes': 90,
    'sentenca.resultado': 85,
    'defesa.fundamentosPrincipais': 80,
    'acusado.dataNascimento': 50,
    'acusado.cpf': 50,
    'defesa.provasAFavor': 70
  };

  return priorities[`${category}.${field}`] || 50;
};

/**
 * Calcula confian√ßa da an√°lise (0-100) com pesos para campos cr√≠ticos
 */
const calculateConfidence = (extractedData) => {
  if (!extractedData || typeof extractedData !== 'object') return 0;

  let totalScore = 0;
  let maxScore = 0;

  // Pesos para diferentes campos (campos cr√≠ticos t√™m peso maior)
  const fieldWeights = {
    // Campos cr√≠ticos para apela√ß√£o criminal
    'acusado.nome': 25, // Muito importante
    'crimes.acusacoes': 20, // Essencial
    'sentenca.resultado': 20, // Essencial
    'processo.numero': 15, // Importante

    // Campos importantes
    'crimes.artigos': 10,
    'sentenca.pena': 10,
    'sentenca.regime': 10,

    // Campos complementares
    'acusado.dataNascimento': 5,
    'acusado.cpf': 5,
    'processo.comarca': 5,
    'processo.vara': 5,
    'acusado.endereco': 3,
    'evidenciasEncontradas': 2
  };

  // Calcular score baseado nos campos encontrados
  Object.entries(fieldWeights).forEach(([fieldPath, weight]) => {
    maxScore += weight;
    const [category, field] = fieldPath.split('.');

    if (extractedData[category]?.[field]) {
      const value = extractedData[category][field];

      // Verificar se o valor √© v√°lido (n√£o null, n√£o vazio)
      let isValid = false;
      if (Array.isArray(value)) {
        isValid = value.length > 0 && value.every(item => item !== null && item !== '');
      } else {
        isValid = value !== null && value !== '';
      }

      if (isValid) {
        totalScore += weight;
      }
    }
  });

  // Calcular porcentagem
  const confidence = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0;

  // Bonus para campos cr√≠ticos encontrados
  const criticalFields = ['acusado.nome', 'crimes.acusacoes', 'sentenca.resultado'];
  const criticalFound = criticalFields.filter(field => {
    const [category, fieldName] = field.split('.');
    return extractedData[category]?.[fieldName];
  }).length;

  // Bonus de at√© 10 pontos se todos os campos cr√≠ticos foram encontrados
  if (criticalFound === criticalFields.length) {
    confidence = Math.min(100, confidence + 10);
  }

  return Math.max(0, Math.min(100, confidence));
};

/**
 * Gera resumo autom√°tico dos documentos analisados
 */
const generateDocumentAnalysisSummary = (analysisResult, documentCount = 1, promptType = 'apelacao-criminal') => {
  if (!analysisResult || !analysisResult.extractedInfo) {
    return '‚ùå N√£o foi poss√≠vel analisar os documentos.';
  }

  const { extractedInfo, confidence, missingInfo } = analysisResult;
  let summary = '';

  if (promptType === 'apelacao-criminal') {
    summary += `üìÑ **AN√ÅLISE DE DOCUMENTO${documentCount > 1 ? 'S' : ''} - APELA√á√ÉO CRIMINAL**\n\n`;

    // Status da an√°lise
    if (confidence >= 80) {
      summary += `‚úÖ **An√°lise conclu√≠da com alta confian√ßa** (${confidence}%)\n\n`;
    } else if (confidence >= 60) {
      summary += `‚ö†Ô∏è **An√°lise conclu√≠da com confian√ßa m√©dia** (${confidence}%)\n\n`;
    } else {
      summary += `‚ùì **An√°lise conclu√≠da com baixa confian√ßa** (${confidence}%) - Pode precisar de revis√£o\n\n`;
    }

    // Informa√ß√µes cr√≠ticas encontradas
    const criticalInfo = [];

    if (extractedInfo.acusado?.nome) {
      criticalInfo.push(`üë§ **Acusado:** ${extractedInfo.acusado.nome}`);
    }

    if (extractedInfo.processo?.numero) {
      criticalInfo.push(`‚öñÔ∏è **Processo:** ${extractedInfo.processo.numero}`);
    }

    if (extractedInfo.crimes?.acusacoes && extractedInfo.crimes.acusacoes.length > 0) {
      criticalInfo.push(`üö® **Crime(s):** ${extractedInfo.crimes.acusacoes.join(', ')}`);
    }

    if (extractedInfo.sentenca?.resultado) {
      criticalInfo.push(`üìù **Resultado:** ${extractedInfo.sentenca.resultado}`);
    }

    if (criticalInfo.length > 0) {
      summary += `**INFORMA√á√ïES PRINCIPAIS ENCONTRADAS:**\n`;
      criticalInfo.forEach(info => summary += `‚Ä¢ ${info}\n`);
      summary += '\n';
    }

    // Detalhes adicionais
    const additionalInfo = [];

    if (extractedInfo.acusado?.dataNascimento) {
      additionalInfo.push(`üìÖ Nascimento: ${extractedInfo.acusado.dataNascimento}`);
    }

    if (extractedInfo.crimes?.artigos && extractedInfo.crimes.artigos.length > 0) {
      additionalInfo.push(`üìñ Artigo(s): ${extractedInfo.crimes.artigos.join(', ')}`);
    }

    if (extractedInfo.sentenca?.pena) {
      additionalInfo.push(`‚è∞ Pena: ${extractedInfo.sentenca.pena}`);
    }

    if (extractedInfo.sentenca?.regime) {
      additionalInfo.push(`üè¢ Regime: ${extractedInfo.sentenca.regime}`);
    }

    if (additionalInfo.length > 0) {
      summary += `**DETALHES ADICIONAIS:**\n`;
      additionalInfo.forEach(info => summary += `‚Ä¢ ${info}\n`);
      summary += '\n';
    }

    // Status dos documentos
    if (documentCount === 1) {
      summary += `üìã **STATUS:** Documento √∫nico analisado\n\n`;
    } else {
      summary += `üìã **STATUS:** ${documentCount} documentos analisados\n\n`;
    }

    // Pr√≥ximos passos baseado no que falta
    if (missingInfo && missingInfo.length > 0) {
      const criticalMissing = missingInfo.filter(info =>
        ['acusado.nome', 'processo.numero', 'crimes.acusacoes', 'sentenca.resultado'].includes(`${info.category}.${info.field}`)
      );

      if (criticalMissing.length > 0) {
        summary += `‚ö†Ô∏è **INFORMA√á√ïES CR√çTICAS FALTANDO:**\n`;
        criticalMissing.forEach(info => {
          summary += `‚Ä¢ ${info.description}\n`;
        });
        summary += '\nüí° **Recomenda√ß√£o:** Anexe documento complementar ou forne√ßa essas informa√ß√µes manualmente.\n\n';
      } else {
        summary += `‚úÖ **Quase pronto!** Faltam apenas detalhes complementares.\n\n`;
      }
    } else {
      summary += `üéØ **PRONTO PARA GERA√á√ÉO!** Todas as informa√ß√µes necess√°rias foram encontradas.\n\n`;
      summary += `üöÄ **Pr√≥ximo passo:** Digite "GERAR" para elaborar a apela√ß√£o criminal.\n\n`;
    }

  } else {
    // Resumo gen√©rico para outros tipos
    summary += `üìÑ **AN√ÅLISE DE DOCUMENTO${documentCount > 1 ? 'S' : ''}**\n\n`;
    summary += `üìä **Confian√ßa da an√°lise:** ${confidence}%\n\n`;

    if (extractedInfo && Object.keys(extractedInfo).length > 0) {
      summary += `**INFORMA√á√ïES ENCONTRADAS:**\n`;
      Object.entries(extractedInfo).forEach(([key, value]) => {
        if (value && (Array.isArray(value) ? value.length > 0 : value !== '')) {
          summary += `‚Ä¢ ${key}: ${Array.isArray(value) ? value.join(', ') : value}\n`;
        }
      });
    }
  }

  return summary;
};

/**
 * Gera mensagem de progresso para m√∫ltiplos documentos
 */
const generateMultiDocumentProgressMessage = (currentDoc, totalDocs, analysisResult, promptType = 'apelacao-criminal') => {
  let message = `üìÑ **Documento ${currentDoc}/${totalDocs} processado com sucesso!**\n\n`;

  // Adicionar resumo do documento atual
  const summary = generateDocumentAnalysisSummary(analysisResult, 1, promptType);
  message += summary;

  // Mensagem espec√≠fica baseada no tipo de documento e progresso
  if (promptType === 'apelacao-criminal') {
    if (currentDoc === 1 && totalDocs === 2) {
      message += `---\n\nüìã **Aguardando documento complementar:**\n\n`;
      message += `Por favor, anexe o segundo documento (Inqu√©rito Policial) para que eu possa fazer uma an√°lise completa e elaborar a apela√ß√£o criminal.\n\n`;
      message += `üí° **Dica:** O Inqu√©rito Policial geralmente cont√©m detalhes importantes sobre as investiga√ß√µes e pode fornecer informa√ß√µes complementares sobre os crimes e evid√™ncias.`;
    } else if (currentDoc === 2 && totalDocs === 2) {
      message += `---\n\nüéØ **An√°lise completa finalizada!**\n\n`;
      message += `Agora tenho informa√ß√µes de ambos os documentos. `;

      if (analysisResult.hasAllInfo) {
        message += `Digite "GERAR" para elaborar a apela√ß√£o criminal baseada na an√°lise completa.`;
      } else {
        message += `H√° algumas informa√ß√µes complementares que podem melhorar a apela√ß√£o. Digite "GERAR" para continuar ou forne√ßa mais detalhes.`;
      }
    }
  }

  return message;
};

/**
 * Gera mensagem formatada mostrando o que foi extra√≠do e o que falta
 */
const generateDocumentAnalysisMessage = (analysis, questions, documentCount = 1, promptType = 'apelacao-criminal') => {
  // Usar o novo resumo autom√°tico
  const summary = generateDocumentAnalysisSummary(analysis, documentCount, promptType);

  let message = summary;

  // Adicionar perguntas se houver
  if (questions && questions.length > 0) {
    message += `---\n\nüí° **O que preciso de voc√™:**\n\n`;

    if (questions.length === 1) {
      message += `${questions[0].text}${questions[0].suggestion ? `\n\n_Sugest√£o: ${questions[0].suggestion}_` : ''}`;
    } else {
      // Se tem m√∫ltiplas perguntas, mostrar apenas a primeira e oferecer op√ß√£o
      message += `${questions[0].text}${questions[0].suggestion ? `\n\n_Sugest√£o: ${questions[0].suggestion}_` : ''}`;
      message += `\n\n_(Voc√™ pode responder esta pergunta ou digitar "GERAR" para continuar com as informa√ß√µes que temos)_`;
    }
  } else if (analysis.hasAllInfo) {
    // Se tem todas as informa√ß√µes, mostrar mensagem de sucesso
    message += `---\n\nüéâ **EXCELENTE!** `;
    if (documentCount === 1) {
      message += `Analisei seu documento e tenho todas as informa√ß√µes necess√°rias.`;
    } else {
      message += `Analisei seus ${documentCount} documentos e tenho todas as informa√ß√µes necess√°rias.`;
    }
    message += `\n\nüöÄ **Pronto para gerar a apela√ß√£o criminal!**\n`;
    message += `Digite "GERAR" para elaborar o documento.`;
};

/**
 * Valida se h√° informa√ß√µes suficientes para gerar
 */
const validateSufficientInfo = (analysis, missingInfo) => {
  if (!analysis) return false;
  
  const criticalFields = [
    'acusado.nome',
    'processo.numero',
    'crimes.acusacoes',
    'sentenca.resultado'
  ];

  const missingCritical = missingInfo.filter(info => 
    criticalFields.includes(`${info.category}.${info.field}`)
  );

  // Se faltam campos cr√≠ticos, n√£o tem informa√ß√£o suficiente
  if (missingCritical.length > 0) {
    return {
      sufficient: false,
      missing: missingCritical
    };
  }

  return {
    sufficient: true,
    missing: []
  };
};

/**
 * Gera perguntas naturais para as informa√ß√µes faltantes
 */
const generateQuestionsForMissingInfo = (missingInfo, promptType) => {
  if (missingInfo.length === 0) {
    return [];
  }

  const questions = {
    'apelacao-criminal': {
      'acusado.nome': 'üìã Qual √© o nome completo do acusado?',
      'acusado.dataNascimento': 'üìÖ Qual √© a data de nascimento do acusado?',
      'acusado.cpf': 'üÜî Qual √© o CPF ou RG do acusado?',
      'acusado.endereco': 'üè† Qual √© o endere√ßo atual do acusado?',
      'processo.numero': '‚öñÔ∏è Qual √© o n√∫mero do processo?',
      'processo.comarca': 'üèõÔ∏è Qual √© a comarca ou tribunal respons√°vel?',
      'crimes.acusacoes': '‚ö†Ô∏è Quais s√£o os crimes imputados ao acusado?',
      'crimes.artigos': 'üìñ Quais artigos do C√≥digo Penal foram citados?',
      'sentenca.resultado': 'üìù Qual foi o resultado da senten√ßa (condenado/absolvido)?',
      'sentenca.pena': 'üîí Qual foi a pena aplicada?',
      'sentenca.regime': 'üè¢ Qual foi o regime inicial da pena?',
      'defesa.fundamentosPrincipais': 'üéØ Quais s√£o os principais pontos de contesta√ß√£o da senten√ßa?',
      'defesa.provasAFavor': 'üîç Quais provas favorecem o acusado e foram ignoradas?',
      'defesa.circunstanciasPositivas': '‚úÖ Existem circunst√¢ncias atenuantes n√£o reconhecidas?'
    }
  };

  const prompts = questions[promptType] || questions['apelacao-criminal'];

  // Limitar a apenas 2 perguntas priorit√°rias para evitar sobrecarga
  const topQuestions = missingInfo
    .sort((a, b) => b.priority - a.priority)
    .slice(0, 2);

  return topQuestions.map((info, index) => ({
    id: `question-${index}`,
    text: prompts[`${info.category}.${info.field}`] || `Informa√ß√£o faltante: ${info.description}`,
    field: `${info.category}.${info.field}`,
    priority: info.priority,
    required: info.priority > 80,
    suggestion: generateSuggestionForField(info.category, info.field)
  }));
};

/**
 * Gera sugest√£o de resposta para um campo espec√≠fico
 */
const generateSuggestionForField = (category, field) => {
  const suggestions = {
    'defesa.fundamentosPrincipais': 'Ex: Erro na valora√ß√£o das provas, contradi√ß√£o entre depoimentos, viola√ß√£o de direitos fundamentais...',
    'defesa.provasAFavor': 'Ex: Contradi√ß√µes em depoimentos, aus√™ncia de provas diretas, documentos que afastam autoria...',
    'defesa.circunstanciasPositivas': 'Ex: Primariedade, bom comportamento, arrependimento, circunst√¢ncias pessoais favor√°veis...',
    'crimes.acusacoes': 'Ex: Tr√°fico de drogas (art. 33, Lei 11.343/06), homic√≠dio simples (art. 121, CP)...',
    'processo.numero': 'Ex: 5005042-10.2024.8.21.0109',
    'acusado.nome': 'Nome completo do r√©u conforme documentos processuais'
  };

  return suggestions[`${category}.${field}`] || '';
};

/**
 * Verifica se h√° informa√ß√µes suficientes para gerar
 */
const hasEnoughInfoToGenerate = (missingInfo, promptType) => {
  // Para apela√ß√£o criminal, precisa de informa√ß√µes cr√≠ticas
  if (promptType === 'apelacao-criminal') {
    const criticalFields = [
      'acusado.nome',
      'processo.numero',
      'crimes.acusacoes',
      'sentenca.resultado'
    ];

    const hasCriticalInfo = !missingInfo.some(info => 
      criticalFields.includes(`${info.category}.${info.field}`)
    );

    return hasCriticalInfo;
  }

  // Para outros tipos, verificar se tem pelo menos 70% de informa√ß√µes
  return missingInfo.length === 0 || missingInfo.length < 3;
};

/**
 * Parse JSON flex√≠vel para capturar dados mesmo com formato imperfeito
 */
const parseJsonFlexible = (text) => {
  try {
    // Tentar extrair estrutura b√°sica
    const result = {};
    const patterns = {
      acusado: /acusado[:\s]*(.*?)(?=processo|crimes|$)/is,
      processo: /processo[:\s]*(.*?)(?=crimes|sentenca|$)/is,
      crimes: /crimes[:\s]*(.*?)(?=sentenca|defesa|$)/is,
      sentenca: /sentenca[:\s]*(.*?)(?=defesa|$)/is
    };

    Object.entries(patterns).forEach(([key, pattern]) => {
      const match = text.match(pattern);
      if (match) {
        result[key] = match[1].trim();
      }
    });

    return result;
  } catch (error) {
    return {};
  }
};

export default {
  analyzeDocument,
  generateQuestionsForMissingInfo,
  hasEnoughInfoToGenerate,
  REQUIRED_INFORMATION,
  KEYWORDS_MAPPING,
  generateDocumentAnalysisSummary,
  generateDocumentAnalysisMessage,
  generateMultiDocumentProgressMessage
};
